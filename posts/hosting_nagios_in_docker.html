<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>How to Run HAProxy with Docker (In-Depth Guide)</title>
    <link rel="stylesheet" href="posts.css">
</head>
<body>
    <header>
        <!-- Logo goes here -->
	<!-- <img class="logo" src="images/Logo.png" alt="Swanson-IT Logo"> -->
	<h1><a href="index.html">chaostheorytech.com </h1>
         <br>
	 <br>
	<nav>
            <!-- Navigation menu goes here -->
            <ul>
                <li><a href="posts.html">Posts</a></li>
                <li><a href="tools.html">Tools</a></li>
                <li><a href="about.html">About</a></li>
            </ul>
        </nav>

        <!-- Search bar goes here -->
        <input type="text" placeholder="Search">
    </header>
    <div class="post"> <!-- Apply post styling -->

        <header>
            <h1>How to Run HAProxy with Docker (In-Depth Guide)</h1>
            <p>August 9th, 2021</p>
            <p>9 min read</p>
        </header>

        <div class="author-info">
            <p>Nick Ramirez</p>
        </div>

        <article>
            <h2>Run HAProxy With Docker</h2>

            <p>We’ll create three instances of a web application, one instance of HAProxy, and a bridge network to join them together. So, once you’ve installed Docker, use the following command to create a new bridge network in Docker:</p>

            <pre class="code">
$ sudo docker network create --driver=bridge mynetwork
            </pre>

            <p>Then use the docker run command to create and run three instances of the web application. In this example, I use the Docker image jmalloc/echo-server. It’s a simple web app that returns back the details of the HTTP requests that you send to it.</p>

            <pre class="code">
$ sudo docker run -d \
   --name web1 --net mynetwork jmalloc/echo-server:latest

$ sudo docker run -d \
   --name web2 --net mynetwork jmalloc/echo-server:latest

$ sudo docker run -d \
   --name web3 --net mynetwork jmalloc/echo-server:latest
            </pre>

            <p>Notice that we assign each one a unique name and attach it to the bridge network we created. You should now have three web applications running, which you can verify by calling the docker ps command:</p>

            <pre class="code">
$ sudo docker ps

CONTAINER ID   IMAGE                        COMMAND              CREATED              STATUS              PORTS      NAMES
98216bb8c5ff   jmalloc/echo-server:latest   "/bin/echo-server"   About a minute ago   Up About a minute   8080/tcp   web3
ae6accc111d9   jmalloc/echo-server:latest   "/bin/echo-server"   About a minute ago   Up About a minute   8080/tcp   web2
554fafbc2b3b   jmalloc/echo-server:latest   "/bin/echo-server"   About a minute ago   Up About a minute   8080/tcp   web1
            </pre>

            <p>These containers listen on their own port 8080, but we did not map those ports to the host, so they are not routable. We’ll relay traffic to these containers via the HAProxy load balancer. Next, let’s add HAProxy in front of them. Create a file named haproxy.cfg in the current directory and add the following to it:</p>

            <pre class="code">
global
  stats socket /var/run/api.sock user haproxy group haproxy mode 660 level admin expose-fd listeners
  log stdout format raw local0 info

defaults
  mode http
  timeout client 10s
  timeout connect 5s
  timeout server 10s
  timeout http-request 10s
  log global

frontend stats
  bind *:8404
  stats enable
  stats uri /
  stats refresh 10s

frontend myfrontend
  bind :80
  default_backend webservers

backend webservers
  server s1 web1:8080 check
  server s2 web2:8080 check
  server s3 web3:8080 check
            </pre>

            <p>A few things to note:</p>

            <ul>
                <li>In the global section, the stats socket line enables the HAProxy Runtime API and also enables seamless reloads of HAProxy.</li>
                <li>The first frontend listens on port 8404 and enables the HAProxy Stats dashboard, which displays live statistics about your load balancer.</li>
                <li>The other frontend listens on port 80 and dispatches requests to one of the three web applications listed in the webservers backend.</li>
                <li>Instead of using the IP address of each web app, we’re using their hostnames web1, web2, and web3. You can use this type of DNS-based routing when you create a Docker bridge network as we’ve done.</li>
            </ul>

            <p>Next, create and run an HAProxy container and map its port 80 to the same port on the host by including the -p argument. Also, map port 8404 for the HAProxy Stats page:</p>

            <pre class="code">
$ sudo docker run -d \
   --name haproxy \
   --net mynetwork \
   -v $(pwd):/usr/local/etc/haproxy:ro \
   -p 80:80 \
   -p 8404:8404 \
   haproxytech/haproxy-alpine:2.4
            </pre>

            <p>Calling docker ps afterwards shows that HAProxy is running:</p>

            <pre class="code">
$ sudo docker ps

CONTAINER ID   IMAGE                            COMMAND                  CREATED          STATUS          PORTS                                        NAMES
d734d0ef2635   haproxytech/haproxy-alpine:2.4   "/docker-entrypoint.â¦"   3 seconds ago    Up 2 seconds    0.0.0.0:80->80/tcp, 0.0.0.0:8404->8404/tcp   haproxy
            </pre>

            <p>You can access the echo-server web application at <a href="http://localhost">http://localhost</a>. Each request to it will be load balanced by HAProxy. Also, you can see the HAProxy Stats page at <a href="http://localhost:8404">http://localhost:8404</a>.</p>

            <p>If you make a change to your haproxy.cfg file, you can reload the load balancer—without disrupting traffic—by calling the docker kill command:</p>

            <pre class="code">
$ sudo docker kill -s HUP haproxy
            </pre>

            <p>To delete the containers and network, run the docker stop, docker rm, and docker network rm commands:</p>

            <pre class="code">
$ sudo docker stop web1 && sudo docker rm web1
$ sudo docker stop web2 && sudo docker rm web2
$ sudo docker stop web3 && sudo docker rm web3
$ sudo docker stop haproxy && sudo docker rm haproxy
$ sudo docker network rm mynetwork
            </pre>
        </article>

        <footer>
            <p>Conclusion</p>
            <p>In this blog post, you learned how running HAProxy inside of a Docker container can simplify its deployment and lifecycle management. Docker provides a standardized way for deploying applications, making the process repeatable and testable. While the CPU overhead of running Docker is negligible, it can incur extra network latency, but the impact of that depends on your use case and throughput needs.</p>

            <p>To run HAProxy, simply create an HAProxy configuration file and then call the docker run the command with the name of the HAProxy Docker image. HAProxy Technologies supplies up-to-date Docker images on Docker Hub.</p>

            <p>HAProxy Enterprise powers modern application delivery at any scale and in any environment, providing the utmost performance, observability, and security for your critical services. Organizations harness its cutting edge features and enterprise suite of add-ons, which are backed by authoritative, expert support and professional services. Ready to learn more? Sign up for a free trial.</p>

            <p>Want to know when more content like this is published? Subscribe to our blog or follow us on Twitter. You can also join the conversation on Slack.</p>
        </footer>
    </div> <!-- Closing the "post" div -->
</body>
</html>
